---
title: Mini-Project 3
xsubtitle: Transforming colors
summary: |
  In this mini-project, you will explore color types and some novel 
  color transformations.  It will give you the opportunity to practice
  with conditionals and color representations, including the 
  hue-saturation-value color representation.
collaboration: |
  Each student should submit their own responses to this project. You may
  consult other students in the class as you develop your solution.  If you
  receive help from anyone, make sure to cite them in your responses. 
link: true
---
You will create only one file for this mini-project, `transforming-images.rkt`. You should begin your project with [this starter code](../code/mps/transforming-images.rkt)

_Warning! This MP is still under development. Please do not copy the starter code until you've received an announcement that it's okay to do so._

Background
----------

If you've played with an image-editing application like Photoshop, you've likely discovered that such applications provide a wide variety of mechanisms for transforming images. In this assignment, you will build your own versions of some image transformation. While we cannot reasonably explore how to build all such mechanisms, we will consider three kinds of mechanisms in this assignment.

We will start in part one with transformations based on the RGB values of each pixel in the image.

We will introduce a new color representation in part two, HSV (hue-saturation-value) colors, and explore some pixel-based transformations that use HSV colors.

<!--
In part three, we will begin to explore more complex transformations that consider not just a pixel, but also additional information, such as the surrounding pixels and the position of the pixel.
-->

In part three, you will design your own transformations.

Part one: Transforming images by transforming RGB colors
--------------------------------------------------------

As you may recall, we can build a variety of image transformations by using the following model.

```
(define my-color-transformation
  (lambda (c)
    (rgb (some-computation c)
         (some-computation c)
         (some-computation c))))

(define my-image-transformation
  (lambda (img)
    (pixel-map my-color-transformation img)))
```

For example, to swap the red and blue components of an image, we might write the following.

```
;;; (rgb-swap-rb c) -> rgb?
;;;   c : rgb?
;;; Swap the red and blue components of `c`.
(define rgb-swap-rb
  (lambda (c)
    (rgb (rgb-blue c)
         (rgb-green c)
         (rgb-red c))))

;;; (swap-red-blue img) -> image?
;;;   img : image?
;;; Create a new image by swapping the red and blue components of
;;; each pixel in `img`.
(define swap-red-blue
  (lambda (img)
    (pixel-map rgb-swap-rb img)))
```

Here's the procedure in action. We'll start with our kitten.

```
![A picture of a kitten next to the body of a cat on a patterned green rug](../images/kitten.jpg)
```

Here's what happens when we call `swap-red-blue` on that image.

```
![The picture of the kitten, with the kitten and cat's fur looking surprisingly blue](../images/transforming-images/kitten-swap-red-blue.jpg)
```

We can also build `swap-red-blue` by plugging the `lambda` part of `rgb-swap-rb` in place of `rgb-swap-rb`.

```
(define swap-red-blue
  (lambda (img)
    (pixel-map (lambda (c)
                 (rgb (rgb-blue c)
                      (rgb-green c)
                      (rgb-red c)))
               img)))
```

In a few cases, we can use composition to write the color transformations that are applied to each pixel. For example, the following procedure decreases the green component of eachp ixel in an image.

```
;;; (decrease-green img) -> image?
;;;   img : image?
;;; Create a new image by making each pixel of `img` less green (and
;;; a bit more blue and red).
(define decrease-green
  (lambda (img)
    (pixel-map (o rgb-pseudo-complement rgb-greener rgb-pseudo-complement)
               img)))
```

Here's the effect on the kitten.

![The kitten, once again. This time, the fur is a bit redder and the green rug looks much bluer.](../images/transforming-images/kitten-decrease-green.jpg)

We can also use the `cut` operation along with some multi-parameter RGB operations to achieve some transformations. For example, here's one that sets the green component of an image to the maximum value.

```
;;; (maximize-green img) -> image?
;;;   img : image?
;;; Createa a new image by setting the green component of each pixel
;;; to the maximum value.
(define maximize-green
  (lambda (img)
    (pixel-map (cut (rgb-add (rgb 0 255 0) <>)) img)))
```

And here's the effect on our kitten.

![The kitten, now "washed out" with too much green.](../images/transforming-images/kitten-maximize-green.jpg)

Perhaps that wasn't the best transformation to use.

These few procedures give you a sample of the kinds of "basic" RGB transformations we might do.  Of course, we will normally do somewhat more complex transformations than these. Nonetheless, they serve as a starting point for thinking about transformations.

## 1a. Extreme components

Write a procedure, `(rgb-extreme color)`, that takes one parameter, an RGB color, and turns each component to 255 if it is at least 128 and to 0 if it is less than 128.

```
> (rgb->string (rgb-extreme (rgb 0 64 200)))
"0/0/255"
> (rgb->string (rgb-extreme (rgb 128 130 0)))
"255/255/0"
```

We've provided a procedure, `(extreme img)`, that takes one parameter, an image, and applies `rgb-extreme` to each pixel in the image.

[SAMPLE KITTEN FORTHCOMING]

### 1b. Dominant components

Write a procedure, `(rgb-enhance-dominant color), that takes one parameter, an RGB color, and produces a new color in which each component is 255 if it is the largest component (or tied for largest) and 0 otherwise.

```
> (rgb->string (rgb-enhance-dominance (rgb 0 5 0)))
"0/255/0"
> (rgb->string (rgb-enhance-dominance (rgb 200 199 199)))
"255/0/0"
> (rgb->string (rgb-enhance-dominance (rgb 10 0 10)))
"255/0/255"
```

Hint: While you can write this procedure with conditionals, you might be able to achieve more concise code with a clever combination of max, division, rounding, and multiplication.

We've provided a procedure, `(enhance-dominance img)`, that applies `rgb-enhance-dominance` to each pixel in an image.

[SAMPLE KITTEN FORTHCOMING]

### 1c. Flattening

A common technique for manipulating images is known as “flattening” the image. In general, we flatten an image by restricting the values of each component to multiples of a certain value. For example, we might ensure that the components are each multiples of 16, 32, or 64. (We’ll use 255 instead of 256 for the highest multiple.)

How do we convert each component to the appropriate multiple? Consider the case of multiples of 32. If we divide the component by 32, round, and then multiply by 32, we’ll get the nearest multiple of 32. For example,

```
> (* 32 (round (/ 11 32)))
0
> (* 32 (round (/ 21 32)))
32
> (* 32 (round (/ 71 32)))
64
> (* 32 (round (/ 91 32)))
96
> (* 32 (round (/ 211 32)))
224
> (* 32 (round (/ 255 32)))
256
```

As the last example suggests, we may sometimes get a number outside of the range 0..255. Fortunately, the `rgb` function treats 256 (and any reasonable number greater than 256) the same as 255.

Write a procedure, `(image-flatten-32 img)`, that flattens an image by converting each component to the nearest multiple of 32

You may then want to see the effect this procedure has on various images.

[SAMPLE KITTEN TO BE ADDED]

Hint: The sample code for computing nearest multiples of 32 should help.

### 1d. Eight-bit colors

Old-school video games did not provide nearly as many color options as we now have. To save memory, they used "eight bits" for a color, three for the red component, three for the green component, and two for the blue component. If you don't know about bits, that's okay. It means that there are only eight different values for the red component, eight different values for the green component, and four different values for the blue component.

Write a procedure, `(8bit img)`, that converts an image to the equivalent of 8-bit color.

[SAMPLE KITTEN FORTHCOMING]

### 1e. Cycling through colors

As you have seen, when we apply the typical color transformation, such as `rgb-darker` or `rgb-redder`, we eventually reach a limit of 0 or 255. But we can get some interesting effects by "wrapping around" at the end. For example, here's the output from a function that adds 90 to a number, wrapping when we go beyond 255.

```
> (cyclic-add-90 75)
165 ; 75 + 90 = 165
> (cyclic-add-90 165)
255 ; 165 + 90 = 255
> (cyclic-add-90 166)
0 ; 166 + 90 = 256, wrap around to 0
> (cyclic-add-90 167)
1 ; 167 + 90 = 257, wrap around to 1
> (cyclic-add-90 255)
89 ; we wrap around because we hit 255
> (cyclic-add-90 89)
179 ; 89 + 90 = 179
> (cyclic-add-90 179)
13 ; 179 + 90 = 269, 269 - 256 = 13
```

As you might expect, cyclic-add-90 can be written in a variety of ways, combining addition and remainder. Here's one approach.

```
(define cyclic-add-90
  (lambda (val)
    (remainder (+ val 90) 256)))
```

Here's another.

```
(define cyclic-add-90 (o (cut (remainder <> 256)) (cut (+ <> 90))))
```

Write a procedure, `(rgb-cyclic-add c1 c2)`, that takes two RGB colors as input and produces a new color formed by the cyclic addition of the corresponding components of the two colors.

[SAMPLE USES OF `rgb-cyclic-add` FORTHCOMING]

### 1f. Cycling through colors, revisited

Write a procedure, `(rgb-cyclic-subtract c1 c2)`, that behaves much like `rgb-subtract`, except that if the component would end up negative, it cycles back to higher numbers.

[EXAMPLES To BE ADDED]

### 1g. Gamma correction

Because humans do not perceive brightness linearly, some image formats modify the meaning of the stored values’ brightness scale (0-255) to better cover the range of sensitivities with a nonlinear transformation.

The typical transformation is commonly called a _Gamma correction_, for the name of the parameter used to determine the extent of rescaling. In particular, when a color component brightness value is on the real-valued scale of 0-1 (rather than our discrete 0-255 scale), the transformation is given by V_out = `(expt V_in gamma)`. You can [read more about this transformation on Wikipedia](https://en.wikipedia.org/wiki/Gamma_correction#Power_law_for_video_display) if you’re especially curious, or simply forge ahead with the assignment if you’re not.

In this problem, you will implement a series of steps to do this gamma correction on an image.

i. Write a procedure, `(gamma-correct-component component gamma)`, that takes a color component value (i.e., a single number in the range 0-255), and applies the gamma correction described above. Note that you’ll need to rescale the component to the range 0-1 (by dividing) before you exponentiate and rescale it back to 0-255 (by multiplying) afterward.

[EXAMPLES FORTHCOMING]

ii. Write a procedure, (gamma-correct-color c gamma)`, that gamma corrects `c` by applying `gamma-correct-component` to each component.

[EXAMPLES FORTHCOMING]

iii. Write a procedure, `(gamma-correct-two img)`, that lightens the image by gamma-correcting each pixel with a gamma of two.

[EXAMPLES FORTHCOMING]

iv. Write a procedure, `(gamma-correct-half img)`, that darkens the image by gamma-correcting eachp ixel with a gamma of 1/2.

[EXAMPLES FORTHCOMING]

Part two: HSV colors and HSV-based transformations
--------------------------------------------------

As we learned in [the reading on design and color](../readings/design-and-color-reading.html), RGB is not the only way to represent colors on the computer.  For example, we might represent a color in terms of hue, saturation, and value.  _Hue_ represents the pure color (e.g., red, blue, yellow, or a combination of these). _Saturation_ represents the "colorfulness" of the hue in the color. For instance, a completely saturated color would be a pure hue (like red), while a less saturated color might appear just as bright but somewhat faded (perhaps rose or pink). Finally, _Value_ represents the brightness or darkness of the color.

As shown below, hue is represented as an angle, or a point on a circle. Thus, the values 0-360 sweep through colors red (0 degrees), yellow (60 degrees), green (120 degrees), cyan (180 degrees), blue (240 degrees), magenta (300 degrees), and back to red (at 360 or 0 degrees).

![An HSV color wheel](../images/hsv.svg)

[A reference page on HSV](https://education.siggraph.org/static/HyperGraph/color/colorhs.htm) suggests that you can also think of _value_ as how much black pigment you've mixed with the primary color pigment. When the value is 100, all of the pigment is the color and there's no black pigment. When the value is 0, there's no color pigment and much white pigment as possible. That page also suggests that you can also think of _saturation_ as how much white pigment we've added. When the saturation is 100, we have all color pigment and no white pigment. When the saturation is 0, we have no color pigment and all white pigment. 

There's a process by which we can convert an RGB color into an HSV color and an HSV color to an RGB color. Fortunately, you don't need to translate that process into Scheme; we've provided it as part of the `csc151` library.

[EXAMPLES FORTHCOMING]

### 2a. `hsv->string`

### 2b. `string->hsv`

### 2c. `(saturate img)`

### 2d. `(rotate-hue img angle)`

Hint: If the rotated angle is greater than 360, be sure to wrap around properly (e.g., using modulo) to get the correct hue angle.

### 2e. `(set-hue img hue)`

Document and write a procedure, `(set-hue img new-hue)`, that takes an  image and a hue value (in the range 0-360) as parameters and creates a image in which each piel is set to the given hue.

Part three: Freestyle
---------------------

Write two of your own: `my-rgb-transformation` and `my-hsv-transformation`.

Grading rubric
--------------

_This is still being updated._

### Redo or above

Submissions that lack any of these characteristics will get an I.

```
[ ] Passes all of the one-star autograder tests.
[ ] Includes the specified file, `transforming-images.rkt`.
[ ] Includes an appropriate header on the file that indicates the
    course, author, etc.
[ ] Acknowledges appropriately.
[ ] Code runs in DrRacket.
[ ] The question marks in the documentation have been filled in.
```

### Meets expectations or above

Submissions that lack any of these characteristics but have all of the
prior characteristics will get an R.

```
[ ] Passes all of the two-star autograder tests.
[ ] Code is well-formatted with appropriate names and indentation.
[ ] Includes appropriate tests to ensure that the different raw hue 
    computations return the same value on the same inputs.
[ ] Code has been reformatted with Ctrl-I before submitting.
[ ] Code generally follows style guidelines.
[ ] Documentation for all core procedures is correct / has the correct form.
[ ] Includes tests for `is-color?`.
[ ] Includes tests for `color->rgb`.
[ ] Includes tests for `rgb-hue`.
[ ] Includes tests for `rgb-saturation`.
[ ] Includes tests for `rgb-value`.
[ ] `color-palette` shows at least five "related colors" (or should)
```

### Exemplary / Exceeds expectations

Submissions that lack any of these characteristics but have all of the
prior characteristics will get an M.

```
[ ] Passes all of the three-star autograder tests.
[ ] Style is impeccable (or nearly so).
[ ] Avoids repeated work.
[ ] Tests for `rgb-hue` include well-designed edge cases.
[ ] Tests for `rgb-saturation` include well-designed edge cases.
[ ] Tests for `rgb-value` include well-designed edge cases.
[ ] Tests have clear description strings.
[ ] Documentation for all procedures is correct / has the correct form.
```

Q&A
---

Do we have to write tests for the raw hue procedures?

> You do not need to write any other tests for the raw hue procedures
  except for those that ensure that two hue procedures return the
  same value when the two corresponding components are the same.

Can we round our hues to the nearest integer?

> Certainly.  I would recommend it.

Acknowledgments
---------------

Many of these problems were adapted from problems written in the distant past for the old "MediaScheme" version of CSC-151.

The HSV hexagon is adapted from an original by Jacob Rus, available
at
<http://en.wikipedia.org/w/index.php?title=File:HSL-HSV_hue_and_chroma.svg>.
Both the original and our version are licensed under the <ulink
url="http://creativecommons.org/licenses/by-sa/3.0/deed.en"> [Creative
Commons Attribution-Share Alike 3.0 Unported
license](http://creativecommons.org/licenses/by-sa/3.0/deed.en).

In developing parts of this assignment, we relied on conversion formulae from [RapidTables](https://www.rapidtables.com), available at <https://www.rapidtables.com/convert/color/rgb-to-hsv.html>.

